// Generated by CoffeeScript 2.3.2
(function() {
  var AbstractClientStore, Sequelize, bruteStore, moment;

  AbstractClientStore = require('express-brute/lib/AbstractClientStore');

  moment = require('moment');

  Sequelize = require('sequelize');

  module.exports = bruteStore = class bruteStore {
    constructor(sequelize, table, options, callback) {
      AbstractClientStore.apply(this, arguments);
      this.defaults = {
        prefix: '',
        logging: false
      };
      this.options = Object.assign({}, this.defaults, options);
      this._table = sequelize.define(table, {
        _id: {
          type: Sequelize.STRING,
          unique: true
        },
        expires: {
          type: Sequelize.DATE
        },
        firstRequest: {
          type: Sequelize.DATE
        },
        lastRequest: {
          type: Sequelize.DATE
        },
        count: {
          type: Sequelize.INTEGER
        }
      });
      this._table.sync().then(() => {
        if (this.options.logging) {
          console.log(`bruteStore initialized - table ${table} created`);
        }
        return callback(this);
      }).catch(() => {
        if (this.options.logging) {
          console.log(`Failed to initialize bruteStore - table ${table}`);
        }
        return callback(this);
      });
    }

    set(key, value, lifetime, callback) {
      var _id, expiration;
      _id = this.options.prefix + key;
      expiration = lifetime ? (moment().add(lifetime, 'seconds')).toDate() : null;
      return this._table.findOne({
        where: {
          _id: _id
        }
      }).then((doc) => {
        if (doc) {
          doc._id = _id;
          doc.count = value.count;
          doc.lastRequest = value.lastRequest;
          doc.firstRequest = value.firstRequest;
          doc.expires = expiration;
          return doc.save();
        } else {
          return this._table.create({
            _id: _id,
            count: value.count,
            lastRequest: value.lastRequest,
            firstRequest: value.firstRequest,
            expires: expiration
          });
        }
      }).then(function(doc) {
        typeof callback === 'function' && callback();
        return null;
      }).catch(function(err) {
        typeof callback === 'function' && callback(err);
        return null;
      });
    }

    get(key, callback) {
      var _id;
      _id = this.options.prefix + key;
      return this._table.findOne({
        where: {
          _id: _id
        }
      }).then((doc) => {
        if (doc && new Date(doc.expires).getTime() < new Date().getTime()) {
          return this._table.destroy({
            where: {
              "_id": _id
            }
          }).then(function() {
            return null;
          });
        }
        if (doc) {
          return Promise.resolve({
            count: doc.count,
            lastRequest: new Date(doc.lastRequest),
            firstRequest: new Date(doc.firstRequest)
          });
        }
        return Promise.resolve();
      }).then(function(data) {
        if (!data) {
          data = void 0;
        }
        typeof callback === 'function' && callback(null, data);
        return null;
      }).catch(function(err) {
        typeof callback === 'function' && callback(err);
        return null;
      });
    }

    reset(key, callback) {
      var _id;
      _id = this.options.prefix + key;
      return this._table.destroy({
        where: {
          "_id": _id
        }
      }).then(function(doc) {
        return typeof callback === 'function' && callback(null, doc);
        return null;
      }).catch(function(err) {
        return typeof callback === 'function' && callback(err, null);
        return null;
      });
    }

  };

}).call(this);
